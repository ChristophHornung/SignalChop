namespace Crosberg.SignalChop;

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

/// <summary>
/// The main program, note that we use Dragonfruit to create a custom main method.
/// </summary>
internal class Program
{
	private readonly Dictionary<string, SignalChopCommand> commands;
	private readonly SignalChopper chopper;

	public Program()
	{
		this.chopper = new SignalChopper();
		this.commands = new Dictionary<string, SignalChopCommand>();
		this.AddCommand(new ListenCommand());
		this.AddCommand(new StopListenCommand());
		this.AddCommand(new ConnectCommand());
		this.AddCommand(new QuitCommand());
		this.AddCommand(new SendCommand());
		this.AddCommand(new InvokeCommand());
		this.AddCommand(new HelpCommand(this.commands));
	}

	/// <summary>
	/// A simple generic signalR sender/receiver.
	/// </summary>
	/// <param name="commandFile">An optional command file that will be executed line by line.</param>
	/// <param name="quite">Whether to output status information or restrict the output to received json only.</param>
	/// <param name="verbose">If set prints out verbose information for debugging.</param>
	/// <param name="exitAfterCount">An integer to indicate how many messages to retrieve before quitting. 0 indicates that no auto-exit will occur.</param>
	/// <returns>The status code.</returns>
	// ReSharper disable once UnusedMember.Local Generated by Dragonfruit.
	private static async Task<int> Main(string? commandFile = null, bool quite = false, bool verbose = false,
		int exitAfterCount = 0)
	{
		return await new Program().Run(commandFile, quite, verbose, exitAfterCount);
	}

	private static string[] ParseMultiSpacedArguments(string commandLine)
	{
		bool isLastCharSpace = false;
		char[] parameterCharacters = commandLine.ToCharArray();
		bool inQuote = false;
		for (int index = 0; index < parameterCharacters.Length; index++)
		{
			if (parameterCharacters[index] == '\'')
			{
				inQuote = !inQuote;
			}

			if (!inQuote && parameterCharacters[index] == ' ' && !isLastCharSpace)
			{
				parameterCharacters[index] = '\n';
			}

			isLastCharSpace = parameterCharacters[index] == '\n' || parameterCharacters[index] == ' ';
		}

		return new string(parameterCharacters).Split('\n');
	}

	private void AddCommand(SignalChopCommand command)
	{
		this.commands.Add(command.Name, command);
	}

	private async Task<int> Run(string? commandFile, bool quite, bool verbose, int exitAfterCount)
	{
		this.chopper.WaitCount = exitAfterCount;
		this.chopper.QuiteMode = quite;
		this.chopper.VerboseMode = verbose;
		if (!quite && string.IsNullOrEmpty(commandFile))
		{
			this.ShowGeneralHelp();
		}

		try
		{
			if (!string.IsNullOrEmpty(commandFile))
			{
				if (!File.Exists(commandFile))
				{
					await Console.Error.WriteLineAsync($"Command file {commandFile} not found.");
					return -1;
				}

				if (!quite)
				{
					await Console.Error.WriteLineAsync($"Executing command file {commandFile}");
				}

				foreach (string line in await File.ReadAllLinesAsync(commandFile))
				{
					await this.RunCommand(line);
				}
			}

			while (true)
			{
				string? line = Console.ReadLine();
				if (line != null)
				{
					await this.RunCommand(line);
				}
			}
		}
		catch (Exception e)
		{
			Console.Error.WriteLine(e);
			return 1;
		}
	}

	private void ShowGeneralHelp()
	{
		Console.Error.WriteLine(
			"""
			Available Commands: 
			Connect <server>;
			Listen <method>;
			Send <method> <parameters>[];
			Invoke <method> <parameters>[];
			Help <method>;
			Quit [afterCountMessages]; 
			""");
	}

	private async Task RunCommand(string line)
	{
		string[] splitCommand = ParseMultiSpacedArguments(line);
		string command = splitCommand[0];
		if (this.commands.TryGetValue(command, out SignalChopCommand? c))
		{
			await c.Execute(this.chopper, splitCommand[1..]);
		}
		else
		{
			await Console.Error.WriteLineAsync("Unknown command");
			this.ShowGeneralHelp();
		}
	}
}