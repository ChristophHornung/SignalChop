using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace Crosberg.SignalChop
{
	/// <summary>
	/// The main program, note that we use Dragonfruit to create a custom main method.
	/// </summary>
	internal class Program
	{
		private readonly Dictionary<string, SignalChopCommand> commands;
		private readonly SignalChopper chopper;

		public Program()
		{
			this.chopper = new SignalChopper();
			this.commands = new Dictionary<string, SignalChopCommand>();
			this.AddCommand(new ListenCommand());
			this.AddCommand(new StopListenCommand());
			this.AddCommand(new ConnectCommand());
			this.AddCommand(new QuitCommand());
			this.AddCommand(new SendCommand());
			this.AddCommand(new HelpCommand(this.commands));
		}

		/// <summary>
		/// A simple generic signalR sender/receiver.
		/// </summary>
		/// <param name="commandFile">An optional command file that will be executed line by line.</param>
		/// <param name="quite">Whether to output status information or restrict the output to received json only.</param>
		/// <param name="verbose">If set prints out verbose information for debugging.</param>
		/// <param name="exitAfterCount">An integer to indicate how many messages to retrieve before quitting. 0 indicates that no auto-exit will occur.</param>
		/// <returns>The status code.</returns>
		// ReSharper disable once UnusedMember.Local Generated by Dragonfruit.
		private static async Task<int> Main(string? commandFile = null, bool quite = false, bool verbose = false,
			int exitAfterCount = 0)
		{
			return await new Program().Run(commandFile, quite, verbose, exitAfterCount);
		}

		private static string[] ParseMultiSpacedArguments(string commandLine)
		{
			var isLastCharSpace = false;
			char[] parameterCharacters = commandLine.ToCharArray();
			bool inQuote = false;
			for (int index = 0; index < parameterCharacters.Length; index++)
			{
				if (parameterCharacters[index] == '\'')
				{
					inQuote = !inQuote;
				}

				if (!inQuote && parameterCharacters[index] == ' ' && !isLastCharSpace)
				{
					parameterCharacters[index] = '\n';
				}

				isLastCharSpace = parameterCharacters[index] == '\n' || parameterCharacters[index] == ' ';
			}

			return new string(parameterCharacters).Split('\n');
		}

		private void AddCommand(SignalChopCommand command)
		{
			this.commands.Add(command.Name, command);
		}

		private async Task<int> Run(string? commandFile, bool quite, bool verbose, int exitAfterCount)
		{
			this.chopper.WaitCount = exitAfterCount;
			this.chopper.QuiteMode = quite;
			this.chopper.VerboseMode = verbose;
			if (!quite && string.IsNullOrEmpty(commandFile))
			{
				this.ShowGeneralHelp();
			}

			try
			{
				if (!string.IsNullOrEmpty(commandFile))
				{
					if (!File.Exists(commandFile))
					{
						await Console.Error.WriteLineAsync($"Command file {commandFile} not found.");
						return -1;
					}

					if (!quite)
					{
						await Console.Error.WriteLineAsync($"Executing command file {commandFile}");
					}

					foreach (var line in await File.ReadAllLinesAsync(commandFile))
					{
						await this.RunCommand(line);
					}
				}

				while (true)
				{
					await this.RunCommand(Console.ReadLine());
				}
			}
			catch (Exception e)
			{
				Console.Error.WriteLine(e);
				return 1;
			}
		}

		private void ShowGeneralHelp()
		{
			Console.Error.WriteLine(
				"Available Commands: Connect<server>; Listen <method>; Send <method> <parameters>[]; Help <method>; Quit [afterCountMessages]; ");
		}

		private async Task RunCommand(string line)
		{
			string[] splitCommand = ParseMultiSpacedArguments(line);
			string command = splitCommand[0];
			if (this.commands.ContainsKey(command))
			{
				await this.commands[command].Execute(this.chopper, splitCommand[1..]);
			}
			else
			{
				await Console.Error.WriteLineAsync("Unknown command");
				this.ShowGeneralHelp();
			}
		}
	}
}